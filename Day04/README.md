# 知识点总结
## 基础数据类型
- boolean数据类型不参与任何的类型转换
### 基础数据类型的默认值
   整型的默认值都是0，浮点型的默认值都是0.0，布尔类型的默认值是false，
字符型的默认值是一个什么都不是的的单个字符'\u0000'
- boolean类型的数据并不是只占一位
``` 
    boolean类型在官方文档中并没有没有给出精确的定义，
    《Java虚拟机规范》给出了4个字节，和boolean数组1个字节的定义，
    具体还要看虚拟机实现是否按照规范来，所以1个字节、4个字节都是有可能的。
    这其实是运算效率和存储空间之间的博弈，两者都非常的重要。
```
    
### 基础数据类型自动转换
源数据类型的范围是否包含在目标数据类型的范围内，
如果包含就能够自动转换；如果不包含，就不能进行自动类型转换
- char类型是比较特殊的，涉及char的类型转换需要特别注意。
- 整型数据可以转换为浮点型数据，但会由于内存存放方式不同，可能会出现精度丢失。
### 基础数据类型的强制转换
- 强制类型转化的格式为在初始化时，使用括号标明目标数据类型。
- 强制类型转换时，常常会发生精度损失，甚至转换异常、达不到预期效果的情况，
所以，强制类型转换的使用一定要谨慎。
## 引用（复合）数据类型
- 初始化它们都是用new关键字
- 基础数据类型存放在栈中，复合数据类型存放在堆中。
- 引用数据类型在栈中存放的是对象的地址。用new新建一个对象后，在堆中开辟一个地址空间，
然后在该空间中依照类的模板生成一个“对象”，当对模板的值进行赋值时，则相应地修改数值，
让这个“对象”成为真正的对象。
- 基础数据类型在栈中直接存放的是数据，而引用数据类型存放的是指引向堆中的地址。

## 算术运算符
- 自增自减运算：符号位在前，先运算在操作（赋值）；操作数在前，先操作（赋值）后运算
- 所有byte、short、char类型的数据在运算时，都会被提升为int类型；
    如果在表达式中存在某个操作数是long类型的，那么整个表达式都提升为long型的；
    如果在表达式中存在某个操作数是float类型的或者运算结果是float类型的，
    那么整个表达式都提升为float类型的；double类型也是同理。
- Infinity称之为无限，-Infinity称之为负无限；NaN为无数据
