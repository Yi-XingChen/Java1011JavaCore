# 内部类以及抽象类知识总结
## 内部类
#### 概念
- 在类a的内部定义另一个类b,此时类b就是内部类，而类a就成了外部类。
- 格式：
```text
修饰符 class 外部类的名称 {
	// 外部类的成员

	修饰符 class 内部类的名称 {
		// 内部类的成员
	}
}
```

### 访问
- 一般类只能public和default两种类型的访问权限
- 同一个包下有A,B,C三个类，如果想让Ｃ类只允许Ａ类访问，不让Ｂ访问，这时就可以将C类作为A的内部类来实现，
在B中要想访问C类，必须通过A类，并且前提是C类的修饰符不是private。
- 内部类是外部类的一个成员，与成员变量、成员方法等同级，所以内部类的访问权限也可以使用四种。
- 内部类引用外部类当前的对象，需要用“外部类名”.this 的形式。
- 内部类可以访问外部类静态的方法和属性。
- 外部类访问内部类的属性和方法需要借助内部类实例化的对象来操作。
- 外部类与内部类编写在同一个java源文件中，会分别编译成两个class文件，且内部类的命名是特定的，如：OuterDemo$InnerDemo.class。

### 静态内部类
- static不能修饰外部类，静态内部类属于外部类的类访问权限，所有对象都共享该静态内部类。
- 如果想在内部类中声明静态的成员，那么该内部类必须是静态内部类。反之，不然。静态内部类中可以没有一个静态成员。
- 静态内部类的对象实例化过程与内部类的实例化过程完全不同。如下代码中，前两行用于比较两者实例化的区别，
后面的用于说明无法实例化的错误写法。
```text
//静态内部类的对象实例化过程
OuterStaticDemo.InnerStaticDemo innerStaticDemo = new OuterStaticDemo.InnerStaticDemo();
//内部类的实例化过程
InnerDemo innerDemo1 = new InnerDemo();

//使用内部类实例化对象的方式是无法完成静态内部类的实例化的
/*OuterStaticDemo outerStaticDemo = new OuterStaticDemo();
OuterStaticDemo.InnerStaticDemo innerStaticDemo1 = outerStaticDemo.new InnerStaticDemo();
*/
//不能直接通过外部类来访问内部类的构造函数
//OuterStaticDemo.InnerStaticDemo innerStaticDemo = OuterStaticDemo.new InnerStaticDemo();
```
- 静态成员中不允许出现this关键字。
- 静态内部类静态成员的访问必须要使用“类名.静态成员”的方法；静态内部类的非静态成员不能直接访问，需要通过对象来访问。

##### 嵌套内部类
- 嵌套内部类的使用要符合Java对于内部类的语法定义，但这种方式太过晦涩难懂，嵌套内部类几乎不被使用。

- 内部类是支持final关键字的语法语义的！

##### 局部内部类
- 概念：将内部类编写在方法之中，这个类就叫局部内部类，又叫方法内部类。
- 局部内部类只能在定义该内部类的方法内实例化，不可以在此方法外对其实例化。
- 由于方法内部类只能在方法内部生效，因此不能使用访问权限修饰符进行修饰。需要注意的是，这里不定义访问权限修饰符与default权限是不同的。

### 匿名内部类
- 匿名内部类就是没有名字的内部类。匿名内部类在使用的时候再定义、构造类。
- 特性：
    1. 因为没有名字，所以匿名内部类只可以使用一次。
    2. 匿名内部类常用来简化代码的编写。
    3. 使用匿名内部类有一个前提条件，匿名内部类必须继承一个父类或实现一个接口。

` Father father = new Son()；`
上述代码中，father对象本质上虽然是子类的实例化对象，但只能以父类为规范来调用父类内部的属性或方法。
如果子类重写了父类的同名方法后，father调用父类的方法时，调用的是子类的内部代码。

通用格式：
```text
new 继承父类或者实现接口的名称 (构造参数的实参列表){
	//匿名内部类的成员定义，一般定义的内容为：重写父类的同名方法或者实现接口的抽象方法
}
```

分类：
    1. 继承式的匿名内部类，继承一个父类或者抽象类。
    2. 接口式的匿名内部类，实现一个接口。
    3. 参数式的匿名内部类，在作为实参时将匿名内部类传递到对应的方法中去。
    
注意事项：
    1. 使用匿名内部类时，必须继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口。
    2. 匿名内部类中不能定义构造方法。
    3. 匿名内部类中不能存在任何的静态成员变量和静态方法（匿名内部类本身就是通过new关键字来出现的，它在构建的过程中就实例化了对象）。
    4. 匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。
    5. 当匿名内部类使用局部变量时，由于JDK1.8的改进，我们可以不用显示的声明局部变量为final，但该变量本质上还是final。

## 抽象类
#### 概念
- 抽象方法：使用abstract修饰的方法，方法只有声明部分，没有方法体，即没有花括号的内容部分。
- 抽象类：使用abstract修饰的类。包含抽象方法的类，一定是抽象类。
- 格式：
```text
访问权限修饰符 abstract class 抽象类名{
		属性；
		普通方法；
		访问权限修饰符 abstract 返回值类型 方法名称（参数）;          //抽象方法（没有方法体）
}
```

- 抽象类是无法被实例化。
- 抽象类只能作为一个父类，被子类来继承。
- 子类继承抽象父类时，要么重写父类的抽象方法，要么也声明为抽象类。

#### 特点
1. 抽象方法和抽象类都必须被abstract关键字修饰。
2. 抽象类中可以没有抽象方法，但是抽象方法一定编写在抽象类中。
3. 抽象类不可以new创建对象，因为调用抽象方法没有意义。抽象类只能用于子类的继承。
4. 抽象类中的抽象方法要被使用，必须由子类重写抽象方法，创建子类对象后再使用子类对象去调用。
如果子类只覆盖了部分抽象方法，那么该子类还是一个抽象类。
5. 抽象类的子类可能是实现了抽象方法的具体类，也可能还是抽象类。
6. 抽象类中的抽象方法不能使用private修饰符修饰，因为private与abstract是冲突的。
7. 抽象类的抽象方法不能使用final修饰，因为final与abstract也是冲突的。
8. 抽象类的抽象方法不能使用static修饰，因为static修饰方法是使该方法称为类的静态方法，为所有对象所共有，但抽象类根本创建不了对象；
同时，抽象方法没有方法体，声明为静态的，类直接调用时也调用不到具体的方法体执行。static与abstract也是冲突的。

##### 注意事项
1. 抽象类本身不能创建对象。
2. 抽象类是有构造方法的，在子类实例化前也会默认调用父类中的无参构造方法。
3. 抽象类专门是用来做父类，被继承的。
4. 抽象类可以没有抽象方法。
5. 有抽象方法的类一定是抽象类。
6. abstract与private、final、static是冲突的，是不能共存的。
7. 抽象类一定是父类。

#####　抽象类与普通类的区别
| 序号 | 对比项   | 抽象类                   | 普通类                     |
| ---- | -------- | ------------------------ | -------------------------- |
| 1    | 定义类   | abstract 关键字          | 没有abstract关键字         |
| 2    | 类成员   | 属性，一般方法，抽象方法 | 属性，一般方法             |
| 3    | 构造方法 | 有，但不能使用           | 可以创建对象，或者赋初始值 |
